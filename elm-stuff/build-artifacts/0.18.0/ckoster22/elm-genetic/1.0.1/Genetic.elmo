var _ckoster22$elm_genetic$Genetic$constantGen = function (val) {
	return A2(
		_elm_lang$core$Random$map,
		_elm_lang$core$Basics$always(val),
		_elm_lang$core$Random$bool);
};
var _ckoster22$elm_genetic$Genetic$generate = F2(
	function (seed, generator) {
		return A2(_elm_lang$core$Random$step, generator, seed);
	});
var _ckoster22$elm_genetic$Genetic$population_size = 20;
var _ckoster22$elm_genetic$Genetic$half_population_size = (_ckoster22$elm_genetic$Genetic$population_size / 2) | 0;
var _ckoster22$elm_genetic$Genetic$Organism = F2(
	function (a, b) {
		return {dna: a, points: b};
	});
var _ckoster22$elm_genetic$Genetic$generateInitialPopulation = function (options) {
	var _p0 = A3(
		_ckoster22$elm_genetic$NonemptyHelper$randomNonemptyList,
		_ckoster22$elm_genetic$Genetic$population_size,
		options.initialSeed,
		A2(
			_elm_lang$core$Random$map,
			function (asciiCodes) {
				return A2(
					_ckoster22$elm_genetic$Genetic$Organism,
					asciiCodes,
					options.evaluateSolution(asciiCodes));
			},
			options.randomDnaGenerator));
	var initialGeneration = _p0._0;
	var seed = _p0._1;
	return {
		ctor: '_Tuple2',
		_0: A3(
			_ckoster22$elm_genetic$Genetic_StepValue$new,
			initialGeneration,
			function (_) {
				return _.dna;
			}(
				_mgold$elm_nonempty_list$List_Nonempty$head(initialGeneration)),
			0),
		_1: seed
	};
};
var _ckoster22$elm_genetic$Genetic$childGenerator = F3(
	function (options, parent1, parent2) {
		return A2(
			_elm_lang$core$Random$map,
			function (childDna) {
				return A2(
					_ckoster22$elm_genetic$Genetic$Organism,
					childDna,
					options.evaluateSolution(childDna));
			},
			A2(
				_elm_lang$core$Random$andThen,
				options.mutateDna,
				A2(
					_elm_lang$core$Random$map,
					function (dna1IsFirst) {
						return dna1IsFirst ? A2(options.crossoverDnas, parent1.dna, parent2.dna) : A2(options.crossoverDnas, parent2.dna, parent1.dna);
					},
					_elm_lang$core$Random$bool)));
	});
var _ckoster22$elm_genetic$Genetic$familyGenerator = F3(
	function (options, parent1, parent2) {
		var bestParent = function () {
			var _p1 = options.method;
			if (_p1.ctor === 'MaximizeScore') {
				return (_elm_lang$core$Native_Utils.cmp(parent1.points, parent2.points) > 0) ? parent1 : parent2;
			} else {
				return (_elm_lang$core$Native_Utils.cmp(parent1.points, parent2.points) < 0) ? parent1 : parent2;
			}
		}();
		return A4(
			_elm_lang$core$Random$map3,
			F3(
				function (child1, child2, child3) {
					return {
						ctor: '::',
						_0: child1,
						_1: {
							ctor: '::',
							_0: child2,
							_1: {
								ctor: '::',
								_0: child3,
								_1: {
									ctor: '::',
									_0: bestParent,
									_1: {ctor: '[]'}
								}
							}
						}
					};
				}),
			A3(_ckoster22$elm_genetic$Genetic$childGenerator, options, parent1, parent2),
			A3(_ckoster22$elm_genetic$Genetic$childGenerator, options, parent1, parent2),
			A3(_ckoster22$elm_genetic$Genetic$childGenerator, options, parent1, parent2));
	});
var _ckoster22$elm_genetic$Genetic$bestOrganismsGenerator = F2(
	function (options, bestHalfOfPopulation) {
		var _p2 = bestHalfOfPopulation;
		if (_p2.ctor === '[]') {
			return _ckoster22$elm_genetic$Genetic$constantGen(
				{ctor: '[]'});
		} else {
			if (_p2._1.ctor === '[]') {
				return _ckoster22$elm_genetic$Genetic$constantGen(
					{
						ctor: '::',
						_0: _p2._0,
						_1: {ctor: '[]'}
					});
			} else {
				return A2(
					_elm_lang$core$Random$andThen,
					function (family) {
						return A2(
							_elm_lang$core$Random$map,
							function (organisms) {
								return A2(_elm_lang$core$List$append, organisms, family);
							},
							A2(_ckoster22$elm_genetic$Genetic$bestOrganismsGenerator, options, _p2._1._1));
					},
					A3(_ckoster22$elm_genetic$Genetic$familyGenerator, options, _p2._0, _p2._1._0));
			}
		}
	});
var _ckoster22$elm_genetic$Genetic$nextGenerationGenerator = F2(
	function (options, currPopulation) {
		var sortedPopulation = _mgold$elm_nonempty_list$List_Nonempty$toList(
			A2(
				_mgold$elm_nonempty_list$List_Nonempty$sortBy,
				function (_) {
					return _.points;
				},
				currPopulation));
		var bestHalfOfPopulation = function () {
			var _p3 = options.method;
			if (_p3.ctor === 'MaximizeScore') {
				return A2(_elm_lang$core$List$drop, _ckoster22$elm_genetic$Genetic$half_population_size, sortedPopulation);
			} else {
				return A2(_elm_lang$core$List$take, _ckoster22$elm_genetic$Genetic$half_population_size, sortedPopulation);
			}
		}();
		return A2(
			_elm_lang$core$Random$map,
			function (organismList) {
				return A2(
					_elm_lang$core$Maybe$withDefault,
					currPopulation,
					_mgold$elm_nonempty_list$List_Nonempty$fromList(organismList));
			},
			A2(_ckoster22$elm_genetic$Genetic$bestOrganismsGenerator, options, bestHalfOfPopulation));
	});
var _ckoster22$elm_genetic$Genetic$executeStep = F2(
	function (options, stepValue) {
		var population = _ckoster22$elm_genetic$Genetic_StepValue$solutions(stepValue);
		var sortedPopulation = A2(
			_mgold$elm_nonempty_list$List_Nonempty$sortBy,
			function (_) {
				return _.points;
			},
			population);
		var bestSolution = function () {
			var _p4 = options.method;
			if (_p4.ctor === 'MaximizeScore') {
				return _mgold$elm_nonempty_list$List_Nonempty$head(
					_mgold$elm_nonempty_list$List_Nonempty$reverse(sortedPopulation));
			} else {
				return _mgold$elm_nonempty_list$List_Nonempty$head(sortedPopulation);
			}
		}();
		return A2(
			_elm_lang$core$Random$map,
			function (nextPopulation) {
				return A3(_ckoster22$elm_genetic$Genetic_StepValue$new, nextPopulation, bestSolution.dna, bestSolution.points);
			},
			A2(_ckoster22$elm_genetic$Genetic$nextGenerationGenerator, options, population));
	});
var _ckoster22$elm_genetic$Genetic$recursivelyEvolve = F4(
	function (numGenerations, options, stepValue, seed) {
		recursivelyEvolve:
		while (true) {
			var population = _ckoster22$elm_genetic$Genetic_StepValue$solutions(stepValue);
			var bestOrganismPoints = _ckoster22$elm_genetic$Genetic_StepValue$points(stepValue);
			var bestOrganismDna = _ckoster22$elm_genetic$Genetic_StepValue$solution(stepValue);
			if (A3(options.isDoneEvolving, bestOrganismDna, bestOrganismPoints, numGenerations)) {
				return {ctor: '_Tuple2', _0: stepValue, _1: seed};
			} else {
				var _p5 = A2(
					_ckoster22$elm_genetic$Genetic$generate,
					seed,
					A2(
						_ckoster22$elm_genetic$Genetic$executeStep,
						options,
						A3(_ckoster22$elm_genetic$Genetic_StepValue$new, population, bestOrganismDna, bestOrganismPoints)));
				var nextStepValue = _p5._0;
				var nextSeed = _p5._1;
				var _v4 = numGenerations + 1,
					_v5 = options,
					_v6 = nextStepValue,
					_v7 = nextSeed;
				numGenerations = _v4;
				options = _v5;
				stepValue = _v6;
				seed = _v7;
				continue recursivelyEvolve;
			}
		}
	});
var _ckoster22$elm_genetic$Genetic$evolveSolution = function (options) {
	var _p6 = _ckoster22$elm_genetic$Genetic$generateInitialPopulation(options);
	var initialStepValue = _p6._0;
	var seed2 = _p6._1;
	var _p7 = function () {
		var _p8 = A2(
			_ckoster22$elm_genetic$Genetic$generate,
			seed2,
			A2(_ckoster22$elm_genetic$Genetic$executeStep, options, initialStepValue));
		var stepValue = _p8._0;
		var seed3 = _p8._1;
		return A4(_ckoster22$elm_genetic$Genetic$recursivelyEvolve, 0, options, stepValue, seed3);
	}();
	var stepValue = _p7._0;
	var seed3 = _p7._1;
	return {
		ctor: '_Tuple3',
		_0: _ckoster22$elm_genetic$Genetic_StepValue$solution(stepValue),
		_1: _ckoster22$elm_genetic$Genetic_StepValue$points(stepValue),
		_2: seed3
	};
};
var _ckoster22$elm_genetic$Genetic$Options = F7(
	function (a, b, c, d, e, f, g) {
		return {randomDnaGenerator: a, evaluateSolution: b, crossoverDnas: c, mutateDna: d, isDoneEvolving: e, initialSeed: f, method: g};
	});
var _ckoster22$elm_genetic$Genetic$MinimizePenalty = {ctor: 'MinimizePenalty'};
var _ckoster22$elm_genetic$Genetic$MaximizeScore = {ctor: 'MaximizeScore'};
var _ckoster22$elm_genetic$Genetic$Generation = function (a) {
	return {ctor: 'Generation', _0: a};
};
